import type { FailedAttemptError } from 'p-retry';
import pRetry from 'p-retry';

import type { Response } from '@lib/util/request';
import type { ImageContents, QueuedImage } from '@src/mb_enhanced_cover_art_uploads/types';
import { LOGGER } from '@lib/logging/logger';
import { ArtworkTypeIDs } from '@lib/MB/cover-art';
import { HTTPResponseError } from '@lib/util/request';
import { NetworkError, request } from '@lib/util/request';
import { CONFIG } from '@src/mb_enhanced_cover_art_uploads/config';
import { enqueueImage } from '@src/mb_enhanced_cover_art_uploads/form';
import { CoverArtDownloader } from '@src/mb_enhanced_cover_art_uploads/images/download';
import { getProviderByDomain } from '@src/mb_enhanced_cover_art_uploads/providers';
import { CoverArtProvider } from '@src/mb_enhanced_cover_art_uploads/providers/base';

import { createBlobResponse, createHttpError, createImageFile } from '../test-utils/dummy-data';

jest.mock('p-retry');
jest.mock('@lib/logging/logger');
jest.mock('@lib/util/request');
jest.mock('@src/mb_enhanced_cover_art_uploads/providers');
jest.mock('@src/mb_enhanced_cover_art_uploads/form');

const mockpRetry = jest.mocked(pRetry);
// eslint-disable-next-line jest/prefer-jest-mocked, jest/unbound-method -- jest.mocked doesn't work because of generic return type.
const mockRequestGet = request.get as unknown as jest.Mock<Promise<Response>, [URL | string, unknown]>;
const mockLoggerWarn = jest.mocked(LOGGER.warn);
const mockGetProviderByDomain = jest.mocked(getProviderByDomain);
const mockEnqueueImage = jest.mocked(enqueueImage);

// Fake provider to enable us to control which images are extracted through
// this mock function.
// eslint-disable-next-line jest/prefer-jest-mocked -- Need type annotation.
const mockFindImages = jest.fn() as jest.MockedFunction<CoverArtProvider['findImages']>;
class FakeProvider extends CoverArtProvider {
    public readonly name = 'test';
    public readonly findImages = mockFindImages;
    public readonly supportedDomains = [];
    public readonly favicon = '';
    protected readonly urlRegex = /example\.com\/(.+)/;
}

const fakeProvider = new FakeProvider();

const hooks = {
    onDownloadStarted: jest.fn(),
    onDownloadFinished: jest.fn(),
    onDownloadProgress: jest.fn(),
};

// Cannot use `typeof CoverArtDownloader.downloadImageContents` since it's private in another subproject,
// and the .d.ts files generated by tsc don't include specific types for those members.
// Therefore, its type would be full of `unknown`, leading to type errors here.
type DownloadImageContentsSpy = jest.SpyInstance<Promise<ImageContents>, [URL, string, Record<string, string>]>;

function enableDummyFetch(mock: DownloadImageContentsSpy): void {
    // Return dummy response for fetching images
    mock.mockImplementation((url: URL, filename: string) =>
        Promise.resolve({
            fetchedUrl: url,
            requestedUrl: url,
            wasRedirected: false,
            file: createImageFile({
                name: filename.replace(/\.\w+$/, '') + '.0.jpg',
                mimeType: 'image/jpeg',
            }),
        }));
}

function disableDummyFetch(mock: DownloadImageContentsSpy): void {
    // Restore original implementation of fetchImageContents
    mock.mockRestore();
}

beforeAll(() => {
    // Mock p-retry so that it doesn't retry on image content fetching failure.
    mockpRetry.mockImplementation(((function_) => (function_(0))) as typeof pRetry);
});

beforeEach(() => {
    mockEnqueueImage.mockClear();
    mockFindImages.mockReset();
    hooks.onDownloadFinished.mockClear();
    hooks.onDownloadProgress.mockClear();
    hooks.onDownloadStarted.mockClear();
    mockLoggerWarn.mockReset();
});

describe('downloading image contents', () => {
    let fetchImageContents: typeof CoverArtDownloader.prototype['downloadImageContents'];
    // Used to register when a retry occurs in the p-retry mock, so we can verify in the tests.
    const onRetry = jest.fn();

    beforeAll(() => {
        // Mock retrying behaviour so we can test it.
        mockpRetry.mockImplementation(async (function_, options) => {
            try {
                return await function_(0);
            } catch (error) {
                Object.defineProperties(error, {
                    attemptNumber: { value: 1, writable: false },
                    retriesLeft: { value: 1, writable: false },
                });
                await options?.onFailedAttempt?.(error as FailedAttemptError);
                // Call the onRetry mock so we can verify when a retry would've
                // occurred.
                onRetry();
                return function_(1);
            }
        });
    });

    beforeEach(() => {
        const fetcher = new CoverArtDownloader(hooks);
        fetchImageContents = fetcher['downloadImageContents'].bind(fetcher);
        onRetry.mockClear();
    });

    afterAll(() => {
        mockpRetry.mockImplementation((function_) => Promise.resolve(function_(0)));
    });

    it('rejects on network error', async () => {
        mockRequestGet.mockRejectedValueOnce(new NetworkError(new URL('https://example.com')));

        await expect(fetchImageContents(new URL('https://example.com/broken'), 'test.jpg', 0, {}))
            .rejects.toBeInstanceOf(NetworkError);
        expect(onRetry).not.toHaveBeenCalled();
    });

    it('rejects on HTTP 404 error', async () => {
        mockRequestGet.mockRejectedValue(createHttpError(createBlobResponse({ status: 404 })));

        const result = fetchImageContents(new URL('https://example.com/broken'), 'test.jpg', 0, {});

        await expect(result).rejects.toBeInstanceOf(HTTPResponseError);
        expect(onRetry).not.toHaveBeenCalled();
    });

    it('rejects on text response', async () => {
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/broken',
            blob: new Blob(['test']),
            headers: new Headers({ 'Content-Type': 'text/html; charset=utf-8' }),
        }));

        await expect(fetchImageContents(new URL('https://example.com/broken'), 'test.jpg', 0, {}))
            .rejects.toThrow('Expected to receive an image, but received text. Perhaps this provider is not supported yet?');
    });

    it('rejects on unsupported provider page', async () => {
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/not-an-album',
            blob: new Blob(['test']),
            headers: new Headers({ 'Content-Type': 'text/html; charset=utf-8' }),
        }));
        mockGetProviderByDomain.mockImplementationOnce(() => fakeProvider);

        await expect(fetchImageContents(new URL('https://example.com/not-an-album'), 'test.jpg', 0, {}))
            .rejects.toThrow('This page is not (yet) supported by the test provider, are you sure this page corresponds to a MusicBrainz release?');
    });

    it('rejects on invalid image', async () => {
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/broken',
            blob: new Blob(['test']),
            headers: new Headers({ 'Content-Type': 'application/json' }),
        }));

        await expect(fetchImageContents(new URL('https://example.com/broken'), 'test.jpg', 0, {}))
            .rejects.toThrow('Expected "test.jpg" to be an image, but received application/json.');
    });

    it('rejects on invalid image without content-type header', async () => {
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/broken',
            blob: new Blob(['test']),
        }));

        await expect(fetchImageContents(new URL('https://example.com/broken'), 'test.jpg', 0, {}))
            .rejects.toThrow('Expected "test.jpg" to be an image, but received unknown file type.');
    });

    it('resolves with fetched image', async () => {
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/working',
            blob: new Blob([Uint32Array.from([0x474E5089, 0xDEADBEEF])]),
        }));

        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 0, {}))
            .resolves.toMatchObject({
                file: {
                    type: 'image/png',
                    name: 'test.0.png',
                },
                requestedUrl: {
                    href: 'https://example.com/working',
                },
                fetchedUrl: {
                    href: 'https://example.com/working',
                },
                wasRedirected: false,
            });
    });

    it('retries on 429 response', async () => {
        mockRequestGet.mockRejectedValueOnce(createHttpError(createBlobResponse({
            status: 429,
        })));
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/working',
            blob: new Blob([Uint32Array.from([0x474E5089, 0xDEADBEEF])]),
        }));

        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 0, {}))
            .resolves.toMatchObject({
                file: {
                    type: 'image/png',
                    name: 'test.0.png',
                },
                requestedUrl: {
                    href: 'https://example.com/working',
                },
                fetchedUrl: {
                    href: 'https://example.com/working',
                },
                wasRedirected: false,
            });
        expect(onRetry).toHaveBeenCalledOnce();
    });

    it('rejects on too many 429 responses', async () => {
        mockRequestGet.mockRejectedValueOnce(createHttpError(createBlobResponse({
            status: 429,
        })));
        mockRequestGet.mockRejectedValueOnce(createHttpError(createBlobResponse({
            status: 429,
        })));

        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 0, {}))
            .rejects.toBeInstanceOf(HTTPResponseError);
        expect(onRetry).toHaveBeenCalledOnce();
    });

    it('retains redirection information', async () => {
        mockRequestGet.mockResolvedValueOnce(createBlobResponse({
            url: 'https://example.com/redirected',
            blob: new Blob([Uint32Array.from([0x474E5089, 0xDEADBEEF])]),
        }));

        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 0, {}))
            .resolves.toMatchObject({
                requestedUrl: {
                    href: 'https://example.com/working',
                },
                fetchedUrl: {
                    href: 'https://example.com/redirected',
                },
                wasRedirected: true,
            });
    });

    it('warns when redirect could not be determined', async () => {
        const response = createBlobResponse({
            blob: new Blob([Uint32Array.from([0x474E5089, 0xDEADBEEF])]),
        });
        // Need to set explicitly because `createBlobResponse` creates a random
        // URL if we provide it `undefined`.
        Object.defineProperty(response, 'url', { value: undefined });
        mockRequestGet.mockResolvedValueOnce(response);

        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 0, {}))
            .toResolve();
        expect(mockLoggerWarn).toHaveBeenCalledWith(expect.stringContaining('redirect'));
    });

    it('assigns unique ID to each file name', async () => {
        mockRequestGet
            .mockResolvedValueOnce(createBlobResponse({
                url: 'https://example.com/working',
                blob: new Blob([Uint32Array.from([0x474E5089, 0xDEADBEEF])]),
            }))
            .mockResolvedValueOnce(createBlobResponse({
                url: 'https://example.com/working',
                blob: new Blob([Uint32Array.from([0x474E5089, 0xDEADBEEF])]),
            }));

        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 0, {}))
            .resolves.toMatchObject({
                file: {
                    name: 'test.0.png',
                },
            });
        await expect(fetchImageContents(new URL('https://example.com/working'), 'test.jpg', 1, {}))
            .resolves.toMatchObject({
                file: {
                    name: 'test.1.png',
                },
            });
    });
});

describe('downloading image', () => {
    let mockFetchImageContents: DownloadImageContentsSpy;
    let downloadImage: CoverArtDownloader['downloadImage'];

    const baseCoverArt = {
        types: [],
        comment: '',
        maximisedUrlCandidates: [],
    };

    beforeEach(() => {
        const downloader = new CoverArtDownloader(hooks);
        downloadImage = downloader['downloadImage'].bind(downloader);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Needed to mock private method.
        mockFetchImageContents = jest.spyOn(CoverArtDownloader.prototype as any, 'downloadImageContents') as DownloadImageContentsSpy;
        enableDummyFetch(mockFetchImageContents);
    });

    afterEach(() => {
        disableDummyFetch(mockFetchImageContents);
    });

    describe('without maximisation', () => {
        it('does not maximise the image', async () => {
            await expect(downloadImage({ ...baseCoverArt, originalUrl: new URL('https://example.com/test') }))
                .resolves.toHaveProperty('wasMaximised', false);
        });

        it('uses the URL filename if present', async () => {
            await expect(downloadImage({ ...baseCoverArt, originalUrl: new URL('https://example.com/test.jpg') }))
                .resolves.toHaveProperty('content.name', 'test.0.jpg');
        });

        it('falls back to default filename if none present in URL', async () => {
            await expect(downloadImage({ ...baseCoverArt, originalUrl: new URL('https://example.com/test/') }))
                .resolves.toHaveProperty('content.name', 'image.0.jpg');
        });

        it('retains redirection information', async () => {
            mockFetchImageContents.mockResolvedValueOnce({
                fetchedUrl: new URL('https://example.com/test/redirect'),
                requestedUrl: new URL('https://example.com/test/'),
                wasRedirected: true,
                file: new File([new Blob(['test'])], 'test.0.jpg', { type: 'image/jpeg' }),
            });

            await expect(downloadImage({ ...baseCoverArt, originalUrl: new URL('https://example.com/test/') }))
                .resolves.toMatchObject({
                    finalUrl: {
                        href: 'https://example.com/test/redirect',
                    },
                    maximisedUrl: {
                        href: 'https://example.com/test/',
                    },
                    wasRedirected: true,
                });
        });
    });

    describe('with maximisation', () => {
        const coverArt = {
            ...baseCoverArt,
            originalUrl: new URL('https://example.com/test'),
            maximisedUrlCandidates: [{
                url: new URL('https://example.com/1'),
                filename: '1.png',
                headers: {},
            }, {
                url: new URL('https://example.com/2'),
                filename: '',
                headers: {},
            }],
        };

        it('maximises the image', async () => {
            await expect(downloadImage(coverArt))
                .resolves.toHaveProperty('wasMaximised', true);
        });

        it('fetches the first maximised candidate', async () => {
            await expect(downloadImage(coverArt))
                .resolves.toHaveProperty('content.name', '1.0.jpg');
        });

        it('fetches the second maximised candidate if first fails', async () => {
            mockFetchImageContents.mockRejectedValueOnce(new Error('1.png has an unsupported file type'));

            await expect(downloadImage(coverArt))
                .resolves.toHaveProperty('content.name', '2.0.jpg');
        });

        it('fetches the original URL if both candidates fail', async () => {
            mockFetchImageContents
                .mockRejectedValueOnce(new Error('1.png has an unsupported file type'))
                .mockRejectedValueOnce(new Error('2 has an unsupported file type'));

            await expect(downloadImage(coverArt))
                .resolves.toHaveProperty('content.name', 'test.0.jpg');
        });

        it('fetches nothing if maximised URL already fetched', async () => {
            await downloadImage({ ...coverArt, maximisedUrlCandidates: [], originalUrl: new URL('https://example.com/1') });

            await expect(downloadImage(coverArt))
                .resolves.toBeNull();
        });
    });
});

describe('downloading and enqueuing images', () => {
    let fetcher: CoverArtDownloader;
    let mockDownloadImageContents: DownloadImageContentsSpy;

    beforeEach(() => {
        fetcher = new CoverArtDownloader(hooks);
        // eslint-disable-next-line @typescript-eslint/no-explicit-any -- Needed to mock private method.
        mockDownloadImageContents = jest.spyOn(CoverArtDownloader.prototype as any, 'downloadImageContents') as DownloadImageContentsSpy;
        enableDummyFetch(mockDownloadImageContents);
    });

    afterEach(() => {
        disableDummyFetch(mockDownloadImageContents);
    });

    it('processes single image', async () => {
        const batch = {
            jobUrl: new URL('https://example.com/1'),
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }],
        };

        const result = await fetcher.enqueueCoverArt(batch);

        expect(result.images).toBeArrayOfSize(1);
        expect(result.images[0]).toMatchObject({
            content: {
                name: '1.0.jpg',
            },
            types: [ArtworkTypeIDs.Front],
            comment: 'test',
        });
        expect(result.containerUrl).toBeUndefined();
    });

    it('processes multi-image batch', async () => {
        const batch = {
            jobUrl: new URL('https://example.com/'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }, {
                originalUrl: new URL('https://example.com/2'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Back],
                comment: 'test',
            }],
        };

        const result = await fetcher.enqueueCoverArt(batch);

        expect(result.images).toBeArrayOfSize(2);
        expect(result.images[0]).toMatchObject({
            content: {
                name: '1.0.jpg',
            },
            types: [ArtworkTypeIDs.Front],
            comment: 'test',
        });
        expect(result.images[1]).toMatchObject({
            content: {
                name: '2.0.jpg',
            },
            types: [ArtworkTypeIDs.Back],
            comment: 'test',
        });
        expect(result.jobUrl.href).toBe('https://example.com/');
    });

    it('does not fetch URL which was already fetched', async () => {
        const batch = {
            jobUrl: new URL('https://example.com/1'),
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }],
        };
        await fetcher.enqueueCoverArt(batch);

        await expect(fetcher.enqueueCoverArt(batch))
            .resolves.toHaveProperty('images', []);
    });

    it('does not fetch provider URL which was already fully fetched', async () => {
        const batch = {
            jobUrl: new URL('https://example.com/'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }, {
                originalUrl: new URL('https://example.com/2'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Back],
                comment: 'test',
            }],
        };

        await expect(fetcher.enqueueCoverArt(batch))
            .resolves.toHaveProperty('images', expect.toBeArrayOfSize(2));
        // Second fetch should be blocked, since all previous images are done.
        await expect(fetcher.enqueueCoverArt(batch))
            .resolves.toHaveProperty('images', []);
    });

    it('allows re-fetching provider URL for which some images failed previously', async () => {
        const batch = {
            jobUrl: new URL('https://example.com/'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }, {
                originalUrl: new URL('https://example.com/2'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Back],
                comment: 'test',
            }],
        };
        mockDownloadImageContents.mockRejectedValueOnce(new Error('test'));

        // First fetch will fail to fetch the first of the two images.
        await expect(fetcher.enqueueCoverArt(batch))
            .resolves.toHaveProperty('images', [
                expect.objectContaining({
                    finalUrl: new URL('https://example.com/2'),
                }),
            ]);
        // Second fetch should now only fetch the first image, second one already fetched previously.
        await expect(fetcher.enqueueCoverArt(batch))
            .resolves.toHaveProperty('images', [
                expect.objectContaining({
                    finalUrl: new URL('https://example.com/1'),
                }),
            ]);
    });

    it('does not fetch maximised URL which was already fetched previously', async () => {
        const batch1 = {
            jobUrl: new URL('https://example.com/1'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }],
        };
        // Simulate 1 being maximal version of 2
        const batch2 = {
            jobUrl: new URL('https://example.com/2'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/2'),
                maximisedUrlCandidates: [{
                    url: new URL('https://example.com/1'),
                    filename: '1.png',
                    headers: {},
                }],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }],
        };
        await fetcher.enqueueCoverArt(batch1);

        await expect(fetcher.enqueueCoverArt(batch2))
            .resolves.toHaveProperty('images', []);
    });

    it('allows provider to postprocess images', async () => {
        const mockPostprocessor = jest.fn();
        class PostprocessingProvider extends FakeProvider {
            public override postprocessImage = mockPostprocessor;
        }
        // Simulate it rejecting all but the first image.
        mockPostprocessor.mockImplementation((image) => Promise.resolve(image));
        mockPostprocessor.mockResolvedValueOnce(null);

        const provider = new PostprocessingProvider();
        const batch = {
            jobUrl: new URL('https://example.com/'),
            provider: provider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }, {
                originalUrl: new URL('https://example.com/2'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Back],
                comment: 'test',
            }],
        };

        await expect(fetcher.enqueueCoverArt(batch))
            .resolves.toMatchObject({
                images: [{
                    originalUrl: {
                        href: 'https://example.com/2',
                    },
                }],
            });
    });

    it('enqueues the image', async () => {
        const batch1 = {
            jobUrl: new URL('https://example.com/1'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }],
        };

        await fetcher.enqueueCoverArt(batch1);

        expect(mockEnqueueImage).toHaveBeenCalledExactlyOnceWith(expect.objectContaining({
            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment -- Bad type defs.
            content: expect.objectContaining({
                name: '1.0.jpg',
            }),
            types: [ArtworkTypeIDs.Front],
            comment: 'test',
        }));
    });

    it('calls the hooks', async () => {
        const batch1 = {
            jobUrl: new URL('https://example.com/1'),
            provider: fakeProvider,
            images: [{
                originalUrl: new URL('https://example.com/1'),
                maximisedUrlCandidates: [],
                types: [ArtworkTypeIDs.Front],
                comment: 'test',
            }],
        };
        await fetcher.enqueueCoverArt(batch1);

        expect(hooks.onDownloadStarted).toHaveBeenCalledWith(0, new URL('https://example.com/1'));
        expect(hooks.onDownloadFinished).toHaveBeenCalledWith(0);
    });

    describe('fetching only front images', () => {
        const fetchFrontOnlyPropertySpy = jest.spyOn(CONFIG.fetchFrontOnly, 'get');

        beforeEach(() => {
            fetchFrontOnlyPropertySpy.mockResolvedValue(true);
        });

        afterAll(() => {
            fetchFrontOnlyPropertySpy.mockRestore();
        });

        it('removes non-front images', async () => {
            const batch = {
                jobUrl: new URL('https://example.com/'),
                provider: fakeProvider,
                images: [{
                    originalUrl: new URL('https://example.com/1'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Front],
                    comment: 'test',
                }, {
                    originalUrl: new URL('https://example.com/2'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Back],
                    comment: 'test',
                }],
            };

            await expect(fetcher.enqueueCoverArt(batch))
                .resolves.toMatchObject({
                    images: [{
                        originalUrl: {
                            href: 'https://example.com/1',
                        },
                        types: [ArtworkTypeIDs.Front],
                    }],
                });
            expect(mockDownloadImageContents).toHaveBeenCalledOnce();
        });

        it('removes non-front images regardless of order', async () => {
            const batch = {
                jobUrl: new URL('https://example.com/'),
                provider: fakeProvider,
                images: [{
                    originalUrl: new URL('https://example.com/2'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Back],
                    comment: 'test',
                }, {
                    originalUrl: new URL('https://example.com/1'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Front],
                    comment: 'test',
                }],
            };

            await expect(fetcher.enqueueCoverArt(batch))
                .resolves.toMatchObject({
                    images: [{
                        originalUrl: {
                            href: 'https://example.com/1',
                        },
                        types: [ArtworkTypeIDs.Front],
                    }],
                });
            expect(mockDownloadImageContents).toHaveBeenCalledOnce();
        });

        it('retains multiple front images', async () => {
            const batch = {
                jobUrl: new URL('https://example.com/'),
                provider: fakeProvider,
                images: [{
                    originalUrl: new URL('https://example.com/1'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Front],
                    comment: 'test',
                }, {
                    originalUrl: new URL('https://example.com/2'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Front],
                    comment: 'test',
                }],
            };

            await expect(fetcher.enqueueCoverArt(batch))
                .resolves.toMatchObject({
                    images: expect.toBeArrayOfSize(2) as QueuedImage[],
                });
            expect(mockDownloadImageContents).toHaveBeenCalledTimes(2);
        });

        it('uses first image if no front image defined', async () => {
            const batch = {
                jobUrl: new URL('https://example.com/'),
                provider: fakeProvider,
                images: [{
                    originalUrl: new URL('https://example.com/1'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Medium],
                    comment: 'test',
                }, {
                    originalUrl: new URL('https://example.com/1'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Back],
                    comment: 'test',
                }],
            };

            await expect(fetcher.enqueueCoverArt(batch))
                .resolves.toMatchObject({
                    images: [{
                        originalUrl: {
                            href: 'https://example.com/1',
                        },
                        types: [ArtworkTypeIDs.Medium],
                    }],
                });
            expect(mockDownloadImageContents).toHaveBeenCalledOnce();
        });

        it('allows re-fetching a provider release', async () => {
            const batch = {
                jobUrl: new URL('https://example.com/'),
                provider: fakeProvider,
                images: [{
                    originalUrl: new URL('https://example.com/1'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Front],
                    comment: 'test',
                }, {
                    originalUrl: new URL('https://example.com/2'),
                    maximisedUrlCandidates: [],
                    types: [ArtworkTypeIDs.Back],
                    comment: 'test',
                }],
            };

            await expect(fetcher.enqueueCoverArt(batch))
                .resolves.toMatchObject({
                    images: [{
                        originalUrl: {
                            href: 'https://example.com/1',
                        },
                        types: [ArtworkTypeIDs.Front],
                    }],
                });

            // Call again but allow non-front now, should only return the last one since the first is already
            // done.
            fetchFrontOnlyPropertySpy.mockResolvedValueOnce(false);

            await expect(fetcher.enqueueCoverArt(batch))
                .resolves.toMatchObject({
                    images: [{
                        originalUrl: {
                            href: 'https://example.com/2',
                        },
                        types: [ArtworkTypeIDs.Back],
                    }],
                });
            expect(mockDownloadImageContents).toHaveBeenCalledTimes(2);
        });
    });
});
